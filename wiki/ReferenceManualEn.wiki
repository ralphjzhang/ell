#labels Phase-Implementation,Phase-Design
<wiki:toc max_depth="3" />

= libELL Reference Manual =

This library is written for quick developpement of LL(n) parsers, or other kind of [http://en.wikipedia.org/wiki/EBNF EBNF]-guided C++ applications.

It allows to write EBNF grammars in an executable manner, directly as C++ code.

== The grammar ==

=== Grammar building basis ===

First of all, you will need to be familier to [http://en.wikipedia.org/wiki/EBNF EBNF grammars]. To sum up, EBNF is Backus Naur Form extended to allow the use of regular expression operators.

Let's take the basic grammar which defines how our mathematic expressions works :

{{{
  factor     : "(" expression ")" | INTEGER
  term       : factor ('*' factor | '/' factor) *
  expression : term ('+' term | '-' term) *
}}}


We will now try to write this grammar simply as C++ code.

The definition of each non-terminal (called rule of the grammar) can be represented by an Abstract Syntax Tree, for exemple for the rule `factor`:

{{{
              factor
             /      \
           "("     INTEGER
           /
       expression
         /
       ")"
}}}

In this tree nodes `INTEGER` and `(` are primitives. To the contrary the node `expression` is a link to another tree. Thus, the whole grammar can be represented by a graph.

The C++ code of the grammar will build this syntactic graph in memory. The parser will walk through this graph trying to match each node with the input flow, according to the principle of LL(n) parsing.

*Note:*

  This libray is not a parser generator (like bison ou antlr), but a tool to program an executable high-level grammar.
  So, there is no mecanism to find conflicts between branches : the analysis will stop at the first matching branch find within the grammar. So the order of writing alternatives (with the `|` operator) matters.
  In practical, writing ambiguous branches in the grammar is most of the times useless, as we prefer to group their prefix in a separate rule to write a grammar with a "one-token look-ahead".


Let's come back to the previous tree, and notice that its representation only supports BNF grammars, not EBNF ones. EBNF grammars extend BNF ones by the use of regular expression operators, such as thoses found in posix or perl regexp:
  * `*`: repeat the argument zero or more times
  * `+`: repeat one or more times
  * `!`: argument is optional

To represent these operators, a new tree format is needed:

{{{
              factor
                |
           Alternative
             /      \
      Aggregation    INTEGER
      /        \
     "("    Aggregation
           /          \
       expression     ")"
}}}

Complex operator `*` is represented by a binary node called `Repeat| which is parameterized by the minimum and maximum bound of this repetition (-1 as max bound means no limit).

{{{
        expression
            |
       Aggregation
      /          \
  term         Repeat<0, -1>
                    |
                Alternative
                 /       \
        Aggregation     Aggregation
          /     \         /      \
       '+'      term   '-'       term
}}}


Now, parsing an expression just consists in walking through the tree from root node and consuming tokens each time a primitive is matched.

Here below is the complete grammar translated into C++:

{{{
  factor = real
         | ch('(') >> expression >> ch(')')
         | (ch('-') >> factor)
         | (ch('+') >> factor);

  term = factor >> *( (ch('*') >> factor)
                    | (ch('/') >> factor)
                    | (ch('%') >> factor) );

  expression = term >> *( (ch('+') >> term)
                        | (ch('-') >> term) );
}}}

To keep the spirit of a BNF grammar, we jump to a new line on introducing an alternative with the `|` operator. We can also use parenthesis to avoid the use of an intermediate rule.

Notice that the use of the aggregation operator `>>` instead of just juxtaposing elements.

Now, we can add semantic actions. We do that with the `[]` operator. Such actions are executed only when the element on which they apply matches.

{{{
  factor = real [push] |
           ch('(') >> expression >> ch(')') |
           (ch('-') >> factor) [negate] |
           (ch('+') >> factor);

  term = factor >> *((ch('*') >> factor) [multiply] |
                     (ch('/') >> factor) [divide]);

  expression = term >> *((ch('+') >> term) [add] |
                         (ch('-') >> term) [substract]);
}}}

The full working exemple of this calculator is present in the repository at http://code.google.com/p/ell/source/browse/trunk/libELL/Test/Calc.h


=== Grammar primitives ===

Ell library provides a set of predefined primitives:

|| Primitive || Meaning ||
|| end                  || matches the end of the input ||
|| eps                  || always matches, never consumes ||
|| any                  || matches any input token (eos excepted) ||
|| ch(token)            || matches the given token ||
|| str(s)               || matches a string of input tokens ||
|| error(msg)           || unconditional parsing error generation with custom message ||

For character parsers (ie. when input tokens are C++ primitives like `char`, `int` or `wchar_t`), some specialized parser primitives are provided:

|| Primitive || Meaning ||
|| chset(arg)           || give a charset. Ex: `chset("A-Z_.-")` defines `[A-Z_.-]` ||
|| digit                || `[0-9]` ||
|| range<a, b>          || matches a character in the given range ||
|| lower                || `[a-z]` ||
|| upper                || `[A-Z]` ||
|| alpha                || `[a-zA-Z_]` ||
|| alnum                || `[a-zA-Z0-9_]` ||
|| blank                || `[ \t\n\r]` ||
|| ident                || `lexeme(alpha) >> * alnum)` ||
|| istr(s)              || matches the given string, ignoring case ||
|| visible_ascii        || `[!-~]` (visibles ASCII character) ||
|| utf8nonascii         || valid UTF-8 character outside the ASCII character set ||
|| signed_dec           || signed decimal integer ||
|| real                 || flotting point number (`strtod` format) ||
|| dec                  || decimal integer (`+ digit`) ||
|| hex                  || hexadecimal integer ||
|| oct                  || octal integer ||
|| bin                  || binary integer ||
|| kw(s)                || keyword (equivalent to `no_suffix(str(s), alnum)`) ||
|| ikw(s)               || case-insensitive keyword ||


=== Grammar operators ===

The tables below lists all the operators which can be used to write a grammar. Of course, you can use [http://www.cppreference.com/wiki/operator_precedence C++ operator precedence].

  * Binary operators

|| Name || Notation || Meaning ||
|| Aggregation || `a >> b` || a followed by b ||
|| Alternative || `a | b` || a or b ||
|| Difference || `a - b` || a bereft of b ||
|| List || `a % b` || one or more a separated by b (equivalent to `a >> * (b >> a)`) ||
|| Bound repetition || `a * b` || zero or more a until b (equivalent to `* (a - b) >> b` but much more efficient) ||
|| Association || `a & b` || a followed or preceded by b (equivalent to `(a >> b) | (b >> a)`) ||
|| NoSuffix || no_suffix(a, b) || equivalent to `lexeme(a >> (eps - b))` ||

  * Unary operators

|| Notation || Meaning ||
|| `! a` || Optional match ||
|| `+ a` || One or more repetition ||
|| `* a` || Zero or more repetition ||
|| `no_step_back(rule)` || Walk along the grammar in a LL(1) manner ||
|| `no_action(rule)` || Disable all semantic actions (operator[] has no effect) ||
|| `no_consume(rule)` || Do not consume any input tokens ||
|| `lexeme(rule)` || Defines a new primitive by disabling skipper and allowing step-back ||
|| `repeat<exact>(rule)` || Exact number of repetition ||
|| `repeat<min, max>(rule)` || Repetition within a range ||
|| `repeat(& Class::exact, rule)` || Exact repetition resolved at run-time ||
|| `repeat(& Class::min, &Class::max, rule)` || Range repetition resolved at run-time ||
|| `a [& Class::v]` || Assign the result of matching into a variable. ||
|| `a [& Class::f]` || Call the given member function passing the matching result. ||

*Note:*

  Last two operators are called semantic operators. They have no effect if the rule on which they applied does not match. The variables or methods passed in argument must be members of the Parser class instance used for parsing.

  The types which are allowed for variables or method arguments targetted by the semantic action depend on the node on which the action operator is applied.

  For example, the code below parses a list of space-separated unsigned integers, and assign them into a standard set of signed integers. The repetition operator (`+`) allows to target a STL container : without such a repetition, the compiler would issue an error when trying to resolve the `[ ]` operator.

{{{
struct MyParser : ell::Parser<char>, ell::Grammar<char>
{
    MyParser()
      : ell::Parser<char>(& rule, & blank)
    {
        rule = (+ dec) [& MyParser::list];
   
        parse("12 1 9");
    }
   
    ell::Rule<char> rule;
   
    std::set<int> list;
};
}}}


== The Parser class ==


=== Paramètres ===

L'objet Parser contient toutes les données nécessaires à l'analyse d'un flux
guidé par le parcourt d'une grammaire.  Typiquement, on instancie un parseur à
chaque fois que l'on parse. Il prend en entrée trois objets :
  * la grammaire
  * le skipper
  * le buffer

La grammaire est celle qui guide le parsing. Deux parseurs peuvent travailler
de façon simultanée sur une même grammaire qui est complètement ré-entrante.

Le skipper est également une grammaire. S'il est fourni, il sera appelé entre
chaque éléments de la grammaire (par exemple, pour ignorer les espaces et les
sauts de ligne...). La directive "lexeme"  permet de désactiver le skipper
dans une branche de la grammaire (cf ci-dessous). L'utilisation d'un skipper
permet de se passer de lexeur quand une grammaire est simple.

Le buffer à analyser est un flux de d'unités lexicales quelconques. Il est tout
à fait possible d'imbriquer deux grammaires : la sortie de la première sert
d'entrée à la suivante, etc.

=== Actions sémantiques ===

Les actions sémantiques sont forcément des méthode de l'objet Parser utilisé
pour parser la grammaire, mais il est recommander de dériver cette classe pour
écrire son propre parseur.

Une action sémantique est appelée seulement si son argument de gauche a été
matché (il est bien-sûr possible d'utiliser des parenthèses pour appeler une
action sur un ensemble de règles).

=== Exceptions ===

La classe Parser permet de surcharger la méthode appelée lorsqu'on rencontre
une erreur de parsing (par défaut, une exception std::runtime_error est
générée).

= Tutoriel =

Voyons un exemple sur un cas non trivial. Nous allons écrire une grammaire qui
détecte si un mot est un palindrome (ie un mot qui possède une symétrie dans
l'ordre de ses caractères).

Prenons tout d'abord le soin d'écrire une grammaire sans équivoque :

  palindrome : ALPHA palindrome SAME_ALPHA | ALPHA SAME_ALPHA | ALPHA

Bien-sûr, la primitive SAME_ALPHA n'existe pas, il faut utiliser des appels à
des fonctions pour tester que le caractère est le même. C'est donc une
grammaire contextuelle.

Tenant pour acquis que nous avons une pile (FIFO) à notre disposition :
  * 'push' va mettre le caractère lu dans cette pile
  * 'checkpop' va vérifier que le caractère lu est le même caractère que celui au sommet de la pile, et retirer ce dernier seulement si c'est bien le cas. Dans le cas contraire, cette fonction renverra false, faisant échouer la règle courante, et l'on passera à la ligne suivante de l'alternative
  * 'pop' va simplement retirer le caractère du sommet de la pile

Compétons donc la grammaire :

{{{
    palindrome : ALPHA [push] palindrome ALPHA [checkpop] |
                 ALPHA ALPHA [checkpop] |
                 ALPHA [pop]
}}}

L'opérateur [] indique une action à effectuer seulement si l'argument (situé
devant) a été matché.

Voilà pour la théorie. Maintenant, construisons une classe Grammaire. Sa seule
contrainte est de définir le type token_t permettant l'emploi des primitives de
la bibliothèque (lexèmes prédéfinis, opérateurs et directives détaillés dans
les tableaux précédents, voir Grammar.h).

{{{
    #include <ell/Grammar.h>
   
    class PalinGram : public ell::Grammar<char>
    {
    public:
}}}

La traduction de la grammaire sous forme C++ sera introduite dans le
constructeur.  A noter que 'push', 'checkpop' et 'pop' sont données en tant
qu'adresses de fonctions membres d'une autre classe.

Nous avons ajouté une règle permettant de vérifier que la fin du mot est
atteinte (eos pour End Of Stream), avant de signaler qu'un palindrome a été
trouvé avec la méthode printmsg.

Les macros ELL_NAME_RULE ont pour effet de personnaliser le dump en mode
debug des tentatives du parser pour matcher les règles fournies en argument
(très utile pour débugger).

Voici ce que cela donne :

{{{
      PalinGram()
      {
          palindrome = (souspalindrome >> eos) [& PalinParser::printmsg];

          souspalindrome = alpha [& PalinParser::push] >> souspalindrome >> alpha [& PalinParser::checkpop] |
                           alpha >> alpha [& PalinParser::checkpop] |
                           alpha [& PalinParser::pop];

          ELL_NAME_RULE(palindrome);
          ELL_NAME_RULE(souspalindrome);
      }

  private:
      ell::Rule<char> palindrome, souspalindrome;
  };
}}}

Les primitives (terminaux ou directives prédéfines) sont définies dans <Parser/Grammar.h>.

Et maintenant, le parseur.  Pour plus de faciliter, nous créons un typedef du
type de la class parente.  Dans l'appel au constructeur de la class parente,
nous ne fournissons pas de skipper, car l'analyse est faite au niveau lexème.
On peut voir notre grammaire comme un lexeur qui recherche les lexèmes
palindromes.

{{{
class PalinParser : public ell::Parser<char>
{
public
    PalinParser()
      : ell::Parser(& grammar.palindrome, NULL, NULL)
    { }

    // Override this for custom error management
    void raise_error(const string & msg, int line_number) const
    {
      ...
    }

private:
    static PalinGram grammar;

    stack<string> st;

    void push(const std::string & s)
    {
        st.push(s);
    }

    bool checkpop(const std::string & s2)
    {
        string s1=st.top();
        if (s1 == s2)
        {
            printf("%s == %s", s1.c_str(), s2.c_str());
            st.pop();
        }
        else
        {
            printf("%s != %s", s1.c_str(), s2.c_str());
            // Will be popped by the pop function
        }

        return (s1 == s2);
    }

    void pop()
    {
        st.pop();
    }

    void printmsg(const std::string & s)
    {
        std::cout << s << " est un palindrome!" << std::endl;
    }
};
}}}

Afin de bien souligner la différence entre parseur et grammaire, nous avons
écrit deux classes séparées, et la grammaire est introduite comme un membre
statique de note classe, mais il était tout à fait possible de fusionner
grammaire et parseur.

Maintenant, nous pouvons parser via cette grammaire :

{{{
int main()
{
    PalinParser p;
    p.parse("Bonjour");
    p.parse("kayak");
    p.parse("KaaK");

    return 0;
}
}}}

Et voilà.

Pour bien comprendre comment fonctionne le parseur, il est conseillé de jouer
avec les macros ELL_DEBUG, ELL_DUMP_NODES et ELL_DUMP_SKIPPER définies dans le fichier
Utils.h, puis d'étudier les dumps générés par le parsing.