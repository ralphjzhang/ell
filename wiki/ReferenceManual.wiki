
= libELL: manuel de référence =

Cette bibliothèque permet d'implémenter un parseur très rapidement sous la
forme d'une grammaire EBNF exécutable.

Voici, en quelques mots, le principe de cette bibliothèque, et la façon de l'utiliser.

== La grammaire ==

=== Principe de construction ===

Tout d'abord, si vous ne savez pas ce qu'est une grammaire EBNF, un petit
détour par le web s'impose. En résumé, il s'agit de l'a notation dite "Backus
Naur Form" augmentée des opérateurs utilisés dans les expressions rationnelles.

Prenons la grammaire qui décrit le fonctionnement de nos expressions mathématiques :

{{{
  factor     : "(" expression ")" | INTEGER
  term       : factor ('*' factor | '/' factor) *
  expression : term ('+' term | '-' term) *
}}}

L'idée est de pouvoir insérer cette grammaire sous forme de code C++ exécutable.

On peut voir ce graphe comme un ensemble d'arbres syntaxiques, dont les noeuds
peuvent être soit des primitives (comme INTEGER ou le caractère "(" dans notre
exemple), soit des liens vers d'autres arbres. Chaque règle de la grammaire
(aussi appelée non-terminal dans la terminologie BNF) est la définition d'un
arbre. Par exemple, voici un arbre équivalent à la règle "factor" :

{{{
              factor
             /      \
           "("     INTEGER
           /
       expression
         /
       ")"
}}}

Dans cette arbre, "expression" est un lien vers la règle expression, donc vers
la racine de l'arbre correspondant à la définition d'une expression.

Telle que la bibliothèque est conçue, l'exécution du code de la grammaire
permet de générer un graphe syntaxique.  Parser le flux d'entrée revient alors
à parcourir ce graphe en essayant de faire correspondre chaque noeud à un ou
plusieurs caractères du flux, selon le principe d'une analyse descendante
LL(n).

*Note :*

Cette bibliothèque n'est pas un générateur de grammaire (comme bison ou antlr),
mais juste un outils permettant à un programmeur de coder une grammaire à un
haut niveau.  Il n'y a donc pas de résolution des conflits entre branche :
l'analyse s'arrête dans la première branche valide, selon l'ordre donné par la
grammaire. Ainsi, si on est en présence d'une grammaire LL(n) avec n > 1 et
qu'une branche est le préfixe d'une autre, c'est au programmeur d'écrire la
grammaire dans l'ordre garantissant que le parseur commence par parcourir la
branche la plus longue.  Dans la pratique, il est recommandé de factoriser le
préfixe dans une sous règle afin de revenir vers du LL(1). Quand ce n'est pas
possible, on utilisera plutôt des données contextuelles ajoutées au parseur (la
grammaire devient attribuée).

Revenons à l'arbre précédant et notons que son format est limité à la
représentation de grammaires BNF et non EBNF. Les grammaires EBNF (pour
Extended Backus Naur Form) permettent d'utiliser en prime des opérateurs
semblables à ceux que l'on trouve dans les expressions rationnelles que l'on
trouve dans les scripts sed ou perl :
  * l'opérateur `*` : répétition de zéro à autant de fois que possible
  * l'opérateur ! : facultatif
  * l'opérateur + : au moins une fois
  * et bien d'autres (la liste exhaustive est donnée plus bas)

Pour représenter ces opérateurs, nous optons pour un arbre possédant des noeuds
opérateurs. Voici donc une nouvelle version du même non-terminal 'factor' :

{{{
              factor
                |
           Alternative
             /      \
      Agrégation    INTEGER
      /        \
     "("    Agrégation
           /          \
       expression     ")"
}}}

Avec cette représentation nous pouvons alors représenter les opérateurs
complexes, comme dans la règle expression où l'étoile est représentée par un
noeud Répétition paramétré par les nombres minimum et maximum de répétitions
acceptables (-1 = pas de limite) :

{{{
        expression
            |
       Agrégation
      /          \
  term       Répétition<0, -1>
                    |
                Alternative
                 /       \
        Agrégation     Agrégation
          /     \         /      \
       '+'      term   '-'       term
}}}

Il est intéressant pour le programmeur de bien se représenter les choses de
cette façon car le parsing consiste simplement à parcourir cette arbre depuis
la racine en consommant des lexèmes à chaque terminal validé.

Voici à quoi ressemble de notre grammaire une fois traduite en C++ :

{{{
  factor = real |
           ch('(') >> expression >> ch(')') |
           (ch('-') >> factor) |
           (ch('+') >> factor);

  term = factor >> *((ch('*') >> factor) |
                     (ch('/') >> factor) |
                     (ch('%') >> factor));

  expression = term >> *((ch('+') >> term) |
                         (ch('-') >> term));
}}}

Étant donné que le C++ ne permet pas de juxtaposer deux objets sans opérateur
on introduit l'opérateur d'agrégation : '>>', et pour garder l'esprit d'une
grammaire BNF nous sautons une ligne après chaque opérateur d'alternative. Le
parenthésage permet de regrouper des règles sans usage de non-terminal.

Nous pouvons à présent ajouter des actions sémantiques. Ces dernières seront
exécutées seulement en cas de validation de la règle avec le flux :

{{{
  factor = real [push_number] |
           ch('(') >> expression >> ch(')') |
           (ch('-') >> factor) [do_negate] |
           (ch('+') >> factor);

  term = factor >> *((ch('*') >> factor) [multiply] |
                     (ch('/') >> factor) [divide]);

  expression = term >> *((ch('+') >> term) [add] |
                         (ch('-') >> term) [substract]);
}}}

=== Les opérateurs de la grammaire ===

Voici la liste des opérateurs utilisés pour bâtir une grammaire. Leurs
priorités sont bien-sûr [http://www.cppreference.com/wiki/operator_precedence celles du C++] !

  * opérateurs binaires

|| Nom || Opérateur || Explication ||
|| Agrégation || `a >> b` || a puis b ||
|| Alternative || `a | b` || soit a soit b ||
|| Différence || `a - b` || a mais pas b. Si besoin, on peut implémenter l'opérateur + selon le même modèle ||
|| Liste || `a % b` || autant de a que possible séparés par b (équivalent à `a >> * (b >> a)`) ||
|| Jusqu'à || `a * b` || succession de a terminée par b (équivalent à `* (a - b) >> b`) ||
|| Association || `a & b` || a ou b dans un ordre quelconque (équivalent à `(a >> b) | (b >> a)`) ||

  * opérateurs sémantique : ceux-ci n'ont un effet que si la règle en paramètre est validée

|| Opérateur || Explication || Note ||
|| Assignation || `a [& Class::v]` || Assigne la valeur issue du parsing à la variable v membre d'une classe dérivée de Parser. L'instance est celle du parseur utilisé. ||
|| Appel || `a [& Class::f]` || Appelle la méthode f d'une classe dérivée de Parser. L'instance est celle du parseur utilisé. ||

  * opérateurs unaires de répétition

|| Nom || Opérateur || Description ||
|| Option || `! a` || Matche éventuellement  ||
|| 1 ou plus || `+ a` || Matche au moins une fois ||
|| 0 ou plus || `* a` || Matche autant que possible ||

Si vous avez le besoin, ou l'idée d'un autre opérateur, demandez-le moi !
(samuel.hangouet atgmail. com)


=== Les primitives de la grammaire ===

La bibliothèque fournit un ensemble de terminaux de haut niveau :

|| Primitive || Usage ||
|| eos                  || match la fin du flux (caractère nul) ||
|| eps                  || match toujours, ne consomme rien ||
|| any                  || match n'importe quel caractère (y compris le EOF) ||
|| ch(arg)              || match le caractère indiqué ||
|| digit                || `[0-9]` ||
|| range<a, b>          || caractère ASCII compris entre a et b (compris) ||
|| lower                || `[a-z]` ||
|| upper                || `[A-Z]` ||
|| alnum                || `[a-zA-Z0-9_]` ||
|| blank                || caractère invisible (équivalent à `chset(" \t\n\r")`) ||
|| ident                || équivalent de `lexeme(chset("a-zA-Z_") >> * alnum)` ||
|| str(arg)             || chaîne de caractère ||
|| istr(arg)            || chaîne de caractère en ignorant la casse ||
|| chset(arg)           || un caractère parmi un ensemble ex: "A-Z_.-" ||
|| error(msg)           || génère une erreur ||
|| no_suffix(a, b)      || équivalent de `lexeme(a >> (eps - b))` ||
|| visible_ascii        || caractères visibles du code ASCII-7bit `[!-~]` ||
|| utf8nonascii         || caractères utf8 valide non ASCII ||
|| integer              || entier décimal signé ||
|| real                 || nombre flottant ||
|| dec                  || nombre décimal non signé (+digit) ||
|| hex                  || nombre hexadécimal ||
|| oct                  || nombre octal ||
|| bin                  || nombre binaire ||
|| kw(s)                || mot-clé correspondant à la chaîne fournie (équivalent à `no_suffix(str(s), alnum)`) ||
|| ikw(s)               || mot-clé correspondant à la chaîne fournie, mais en ignorant la casse ||


=== Les directives ===

Une directive s'emploie en parenthésant une expression pour en modifier
l'interprétation. Par exemple, pour indiquer au parseur de matcher une branche
de la grammaire sans rien consommer :

{{{
  no_consume(a >> b)
}}}

|| Directive || Usage ||
|| no_step_back(rule)        || Considère que la grammaire est LL(1), une erreur est donc générée si le sous-arbre de droite d'un opérateur >> ne match pas. La directive lexeme annule l'effet de cette directive (car on considère qu'on entre alors à l'intérieur d'un lexème) ||
|| no_action(rule)           || N'appelle pas les actions (ie l'opérateur [ ] reste sans effet) ||
|| no_consume(rule)          || Ne consomme pas ||
|| lexeme(rule)              || Définition d'un nouveau terminal: annule l'action du skipper et du look-ahead. ||
|| repeat`<`exact>(rule)       || Répétition exacte ||
|| repeat`<`min, max>(rule)    || Répétition dans un intervalle ||
|| repeat(exact, rule)       || Répétition exacte d'une valeur non connue à la compilation ||
|| repeat(min, max, rule)    || Répétition dans un intervalle de valeur non connu à la compilation ||

== Le parseur ==


=== Paramètres ===

L'objet Parser contient toutes les données nécessaires à l'analyse d'un flux
guidé par le parcourt d'une grammaire.  Typiquement, on instancie un parseur à
chaque fois que l'on parse. Il prend en entrée trois objets :
  * la grammaire
  * le skipper
  * le buffer

La grammaire est celle qui guide le parsing. Deux parseurs peuvent travailler
de façon simultanée sur une même grammaire qui est complètement ré-entrante.

Le skipper est également une grammaire. S'il est fourni, il sera appelé entre
chaque éléments de la grammaire (par exemple, pour ignorer les espaces et les
sauts de ligne...). La directive "lexeme"  permet de désactiver le skipper
dans une branche de la grammaire (cf ci-dessous). L'utilisation d'un skipper
permet de se passer de lexeur quand une grammaire est simple.

Le buffer à analyser est un flux de d'unités lexicales quelconques. Il est tout
à fait possible d'imbriquer deux grammaires : la sortie de la première sert
d'entrée à la suivante, etc.

=== Actions sémantiques ===

Les actions sémantiques sont forcément des méthode de l'objet Parser utilisé
pour parser la grammaire, mais il est recommander de dériver cette classe pour
écrire son propre parseur.

Une action sémantique est appelée seulement si son argument de gauche a été
matché (il est bien-sûr possible d'utiliser des parenthèses pour appeler une
action sur un ensemble de règles).

=== Exceptions ===

La classe Parser permet de surcharger la méthode appelée lorsqu'on rencontre
une erreur de parsing (par défaut, une exception std::runtime_error est
générée).

= Tutoriel =

Voyons un exemple sur un cas non trivial. Nous allons écrire une grammaire qui
détecte si un mot est un palindrome (ie un mot qui possède une symétrie dans
l'ordre de ses caractères).

Prenons tout d'abord le soin d'écrire une grammaire sans équivoque :

  palindrome : ALPHA palindrome SAME_ALPHA | ALPHA SAME_ALPHA | ALPHA

Bien-sûr, la primitive SAME_ALPHA n'existe pas, il faut utiliser des appels à
des fonctions pour tester que le caractère est le même. C'est donc une
grammaire contextuelle.

Tenant pour acquis que nous avons une pile (FIFO) à notre disposition :
  * 'push' va mettre le caractère lu dans cette pile
  * 'checkpop' va vérifier que le caractère lu est le même caractère que celui au sommet de la pile, et retirer ce dernier seulement si c'est bien le cas. Dans le cas contraire, cette fonction renverra false, faisant échouer la règle courante, et l'on passera à la ligne suivante de l'alternative
  * 'pop' va simplement retirer le caractère du sommet de la pile

Compétons donc la grammaire :

{{{
    palindrome : ALPHA [push] palindrome ALPHA [checkpop] |
                 ALPHA ALPHA [checkpop] |
                 ALPHA [pop]
}}}

L'opérateur [] indique une action à effectuer seulement si l'argument (situé
devant) a été matché.

Voilà pour la théorie. Maintenant, construisons une classe Grammaire. Sa seule
contrainte est de définir le type token_t permettant l'emploi des primitives de
la bibliothèque (lexèmes prédéfinis, opérateurs et directives détaillés dans
les tableaux précédents, voir Grammar.h).

{{{
    #include <ell/Grammar.h>
   
    class PalinGram : public ell::Grammar<char>
    {
    public:
}}}

La traduction de la grammaire sous forme C++ sera introduite dans le
constructeur.  A noter que 'push', 'checkpop' et 'pop' sont données en tant
qu'adresses de fonctions membres d'une autre classe.

Nous avons ajouté une règle permettant de vérifier que la fin du mot est
atteinte (eos pour End Of Stream), avant de signaler qu'un palindrome a été
trouvé avec la méthode printmsg.

Les macros ELL_NAME_RULE ont pour effet de personnaliser le dump en mode
debug des tentatives du parser pour matcher les règles fournies en argument
(très utile pour débugger).

Voici ce que cela donne :

{{{
      PalinGram()
      {
          palindrome = (souspalindrome >> eos) [& PalinParser::printmsg];

          souspalindrome = alpha [& PalinParser::push] >> souspalindrome >> alpha [& PalinParser::checkpop] |
                           alpha >> alpha [& PalinParser::checkpop] |
                           alpha [& PalinParser::pop];

          ELL_NAME_RULE(palindrome);
          ELL_NAME_RULE(souspalindrome);
      }

  private:
      ell::Rule<char> palindrome, souspalindrome;
  };
}}}

Les primitives (terminaux ou directives prédéfines) sont définies dans <Parser/Grammar.h>.

Et maintenant, le parseur.  Pour plus de faciliter, nous créons un typedef du
type de la class parente.  Dans l'appel au constructeur de la class parente,
nous ne fournissons pas de skipper, car l'analyse est faite au niveau lexème.
On peut voir notre grammaire comme un lexeur qui recherche les lexèmes
palindromes.

{{{
class PalinParser : public ell::Parser<char>
{
public
    PalinParser()
      : ell::Parser(& grammar.palindrome, NULL, NULL)
    { }

    // Override this for custom error management
    void raise_error(const string & msg, int line_number) const
    {
      ...
    }

private:
    static PalinGram grammar;

    stack<string> st;

    void push(const std::string & s)
    {
        st.push(s);
    }

    bool checkpop(const std::string & s2)
    {
        string s1=st.top();
        if (s1 == s2)
        {
            printf("%s == %s", s1.c_str(), s2.c_str());
            st.pop();
        }
        else
        {
            printf("%s != %s", s1.c_str(), s2.c_str());
            // Will be popped by the pop function
        }

        return (s1 == s2);
    }

    void pop()
    {
        st.pop();
    }

    void printmsg(const std::string & s)
    {
        std::cout << s << " est un palindrome!" << std::endl;
    }
};
}}}

Afin de bien souligner la différence entre parseur et grammaire, nous avons
écrit deux classes séparées, et la grammaire est introduite comme un membre
statique de note classe, mais il était tout à fait possible de fusionner
grammaire et parseur.

Maintenant, nous pouvons parser via cette grammaire :

{{{
int main()
{
    PalinParser p;
    p.parse("Bonjour");
    p.parse("kayak");
    p.parse("KaaK");

    return 0;
}
}}}

Et voilà.

Pour bien comprendre comment fonctionne le parseur, il est conseillé de jouer
avec les macros ELL_DEBUG, ELL_DUMP_NODES et ELL_DUMP_SKIPPER définies dans le fichier
Utils.h, puis d'étudier les dumps générés par le parsing.